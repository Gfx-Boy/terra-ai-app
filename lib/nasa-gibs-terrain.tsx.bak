/**
 * Advanced NASA GIBS Tile System
 * Real-time NASA satellite data tiles with terrain displacement
 */

import { useState, useEffect, useRef, useMemo } from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { useTexture } from '@react-three/drei'
import * as THREE from 'three'

// NASA GIBS WMTS tile endpoints (free, no login required)
export const NASA_GIBS_LAYERS = {
  // Vegetation & Agriculture
  MODIS_NDVI: {
    id: 'MODIS_Terra_NDVI_8Day',
    name: 'MODIS NDVI (8-day)',
    baseUrl: 'https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_NDVI_8Day/default/{date}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.png',
    description: 'Vegetation health index'
  },
  MODIS_TRUE_COLOR: {
    id: 'MODIS_Terra_CorrectedReflectance_TrueColor',
    name: 'MODIS True Color',
    baseUrl: 'https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_CorrectedReflectance_TrueColor/default/{date}/GoogleMapsCompatible_Level9/{z}/{y}/{x}.png',
    description: 'Satellite true color imagery'
  },
  VIIRS_NDVI: {
    id: 'VIIRS_SNPP_NDVI',
    name: 'VIIRS NDVI',
    baseUrl: 'https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/VIIRS_SNPP_NDVI/default/{date}/GoogleMapsCompatible_Level8/{z}/{y}/{x}.png',
    description: 'High-resolution vegetation index'
  },
  // Soil & Water
  SMAP_SOIL_MOISTURE: {
    id: 'SMAP_L4_SM_aup',
    name: 'SMAP Soil Moisture',
    baseUrl: 'https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/SMAP_L4_SM_aup/default/{date}/GoogleMapsCompatible_Level6/{z}/{y}/{x}.png',
    description: 'Surface soil moisture'
  },
  // Precipitation
  GPM_PRECIPITATION: {
    id: 'GPM_3IMERGHH_Precipitation_Rate',
    name: 'GPM Precipitation',
    baseUrl: 'https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/GPM_3IMERGHH_Precipitation_Rate/default/{date}/GoogleMapsCompatible_Level8/{z}/{y}/{x}.png',
    description: 'Real-time precipitation'
  },
  // Temperature
  MODIS_LST_DAY: {
    id: 'MODIS_Terra_Land_Surface_Temp_Day',
    name: 'Land Surface Temperature (Day)',
    baseUrl: 'https://gibs.earthdata.nasa.gov/wmts/epsg3857/best/MODIS_Terra_Land_Surface_Temp_Day/default/{date}/GoogleMapsCompatible_Level7/{z}/{y}/{x}.png',
    description: 'Daytime surface temperature'
  }
}

// Utility functions for tile math
export const tileUtils = {
  // Convert lat/lng to tile coordinates
  deg2tile: (lat: number, lon: number, zoom: number) => {
    const x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom))
    const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom))
    return { x, y, z: zoom }
  },

  // Convert tile coordinates to lat/lng bounds
  tile2deg: (x: number, y: number, zoom: number) => {
    const n = Math.pow(2, zoom)
    const west = x / n * 360 - 180
    const east = (x + 1) / n * 360 - 180
    const north = Math.atan(Math.sinh(Math.PI * (1 - 2 * y / n))) * 180 / Math.PI
    const south = Math.atan(Math.sinh(Math.PI * (1 - 2 * (y + 1) / n))) * 180 / Math.PI
    return { north, south, east, west }
  },

  // Generate tile URL with date
  buildTileUrl: (layer: any, x: number, y: number, z: number, date: string = '2024-10-01') => {
    return layer.baseUrl
      .replace('{x}', x.toString())
      .replace('{y}', y.toString())
      .replace('{z}', z.toString())
      .replace('{date}', date)
  },

  // Get tiles for a given bounds and zoom
  getTilesInBounds: (bounds: any, zoom: number) => {
    const tileNW = tileUtils.deg2tile(bounds.north, bounds.west, zoom)
    const tileSE = tileUtils.deg2tile(bounds.south, bounds.east, zoom)
    
    const tiles = []
    for (let x = tileNW.x; x <= tileSE.x; x++) {
      for (let y = tileNW.y; y <= tileSE.y; y++) {
        tiles.push({ x, y, z: zoom })
      }
    }
    return tiles
  }
}

// Advanced terrain tile component with NASA data
export function TerrainTile({ 
  tileX, 
  tileY, 
  zoom, 
  layers, 
  date = '2024-10-01',
  size = 100,
  segments = 128 
}: {
  tileX: number
  tileY: number
  zoom: number
  layers: string[]
  date?: string
  size?: number
  segments?: number
}) {
  const meshRef = useRef<THREE.Mesh>(null)
  const materialRef = useRef<THREE.ShaderMaterial>(null)
  
  // Generate tile URLs for active layers
  const tileUrls = useMemo(() => {
    const urls: Record<string, string> = {}
    layers.forEach(layerId => {
      const layer = NASA_GIBS_LAYERS[layerId as keyof typeof NASA_GIBS_LAYERS]
      if (layer) {
        urls[layerId] = tileUtils.buildTileUrl(layer, tileX, tileY, zoom, date)
      }
    })
    return urls
  }, [tileX, tileY, zoom, layers, date])

  // Load textures for active layers
  const textures = useTexture(Object.values(tileUrls))
  
  // Custom shader for blending multiple NASA layers
  const shaderMaterial = useMemo(() => {
    const uniforms: Record<string, any> = {
      time: { value: 0 },
      opacity: { value: 1.0 }
    }
    
    // Add uniforms for each layer
    layers.forEach((layerId, index) => {
      uniforms[`${layerId}_texture`] = { value: textures[index] || null }
      uniforms[`${layerId}_opacity`] = { value: 1.0 }
    })

    const vertexShader = `
      uniform float time;
      varying vec2 vUv;
      varying vec3 vPosition;
      varying vec3 vNormal;
      
      void main() {
        vUv = uv;
        vPosition = position;
        vNormal = normal;
        
        // Add slight elevation variation (replace with DEM sampling in production)
        vec3 pos = position;
        pos.z += sin(position.x * 0.01) * cos(position.y * 0.01) * 2.0;
        
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    `

    const fragmentShader = `
      uniform float time;
      uniform float opacity;
      ${layers.map(layerId => `
        uniform sampler2D ${layerId}_texture;
        uniform float ${layerId}_opacity;
      `).join('\n')}
      
      varying vec2 vUv;
      varying vec3 vPosition;
      varying vec3 vNormal;
      
      void main() {
        vec4 finalColor = vec4(0.2, 0.15, 0.1, 1.0); // Base soil color
        
        ${layers.map((layerId, index) => {
          if (layerId === 'MODIS_NDVI' || layerId === 'VIIRS_NDVI') {
            return `
              // NDVI layer - convert to vegetation color
              vec4 ndvi = texture2D(${layerId}_texture, vUv);
              float ndviValue = (ndvi.r + ndvi.g + ndvi.b) / 3.0;
              vec3 vegColor = mix(vec3(0.8, 0.6, 0.3), vec3(0.2, 0.8, 0.2), ndviValue);
              finalColor.rgb = mix(finalColor.rgb, vegColor, ${layerId}_opacity * ndviValue);
            `
          } else if (layerId === 'SMAP_SOIL_MOISTURE') {
            return `
              // Soil moisture - blue tint for wet areas
              vec4 moisture = texture2D(${layerId}_texture, vUv);
              float moistureValue = (moisture.r + moisture.g + moisture.b) / 3.0;
              vec3 wetColor = mix(finalColor.rgb, vec3(0.4, 0.6, 0.8), moistureValue * 0.5);
              finalColor.rgb = mix(finalColor.rgb, wetColor, ${layerId}_opacity);
            `
          } else if (layerId === 'MODIS_LST_DAY') {
            return `
              // Temperature - heat map overlay
              vec4 temp = texture2D(${layerId}_texture, vUv);
              float tempValue = (temp.r + temp.g + temp.b) / 3.0;
              vec3 heatColor = mix(vec3(0.2, 0.4, 1.0), vec3(1.0, 0.2, 0.2), tempValue);
              finalColor.rgb = mix(finalColor.rgb, heatColor, ${layerId}_opacity * 0.3);
            `
          } else {
            return `
              // Default layer blending
              vec4 layer${index} = texture2D(${layerId}_texture, vUv);
              finalColor.rgb = mix(finalColor.rgb, layer${index}.rgb, ${layerId}_opacity * 0.7);
            `
          }
        }).join('\n')}
        
        // Add some atmospheric effects
        float fog = smoothstep(0.0, 200.0, length(vPosition));
        finalColor.rgb = mix(finalColor.rgb, vec3(0.7, 0.8, 0.9), fog * 0.1);
        
        gl_FragColor = vec4(finalColor.rgb, opacity);
      }
    `

    return new THREE.ShaderMaterial({
      uniforms,
      vertexShader,
      fragmentShader,
      transparent: true,
      side: THREE.DoubleSide
    })
  }, [layers, textures])

  // Animate shader uniforms
  useFrame((state) => {
    if (materialRef.current) {
      materialRef.current.uniforms.time.value = state.clock.elapsedTime
    }
  })

  // Calculate tile position in world space
  const tilePosition = useMemo(() => {
    const bounds = tileUtils.tile2deg(tileX, tileY, zoom)
    const centerLat = (bounds.north + bounds.south) / 2
    const centerLng = (bounds.east + bounds.west) / 2
    
    // Convert to world coordinates (simplified)
    const x = (centerLng + 180) * (size / 360) - size / 2
    const y = 0
    const z = -(centerLat + 90) * (size / 180) - size / 2
    
    return [x, y, z] as [number, number, number]
  }, [tileX, tileY, zoom, size])

  return (
    <mesh
      ref={meshRef}
      position={tilePosition}
      material={shaderMaterial}
    >
      <planeGeometry args={[size, size, segments, segments]} />
    </mesh>
  )
}

// Main terrain manager component
export function NASATerrainManager({ 
  center, 
  zoom = 8, 
  layers = ['MODIS_TRUE_COLOR'], 
  date = '2024-10-01' 
}: {
  center: { lat: number; lng: number }
  zoom?: number
  layers?: string[]
  date?: string
}) {
  const [visibleTiles, setVisibleTiles] = useState<Array<{x: number, y: number, z: number}>>([])
  
  // Calculate visible tiles based on camera position
  useEffect(() => {
    const bounds = {
      north: center.lat + 1,
      south: center.lat - 1,
      east: center.lng + 1,
      west: center.lng - 1
    }
    
    const tiles = tileUtils.getTilesInBounds(bounds, zoom)
    setVisibleTiles(tiles.slice(0, 9)) // Limit to 3x3 grid for performance
  }, [center, zoom])

  return (
    <>
      {visibleTiles.map((tile) => (
        <TerrainTile
          key={`${tile.x}-${tile.y}-${tile.z}`}
          tileX={tile.x}
          tileY={tile.y}
          zoom={tile.z}
          layers={layers}
          date={date}
        />
      ))}
    </>
  )
}